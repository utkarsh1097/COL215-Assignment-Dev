----------------------------------------------------------------------------------
-- Company: 
-- Engineer: 
-- 
-- Create Date: 19.09.2017 16:45:52
-- Design Name: 
-- Module Name: lab7_divider - Behavioral
-- Project Name: 
-- Target Devices: 
-- Tool Versions: 
-- Description: 
-- 
-- Dependencies: 
-- 
-- Revision:
-- Revision 0.01 - File Created
-- Additional Comments:
-- 
----------------------------------------------------------------------------------

library ieee ;
 use ieee.std_logic_1164.all ;
 use ieee.std_logic_arith.all ;
 use ieee.std_logic_unsigned.all;
entity decider is
port(dividend: in std_logic_vector(7 downto 0);
    divisor: in std_logic_vector(7 downto 0);
    abs_dividend: out std_logic_vector(7 downto 0);
    abs_divisor: out std_logic_vector(7 downto 0);
    cue: out std_logic_vector(1 downto 0));
end decider;


architecture decider of decider is
begin 
  process(dividend, divisor)
  begin
    if(dividend(7) = '0' and divisor(7) = '0') then
      abs_dividend <= dividend;
      abs_divisor <= divisor;
      cue <= "00";
    elsif(dividend(7) = '1' and divisor(7) = '0') then
      cue <= "10";
      abs_dividend <= (not dividend) + 1;
      abs_divisor <= divisor;
    elsif(dividend(7) = '0' and divisor(7) = '1') then
      cue <= "01";
      abs_dividend <=  dividend ;
      abs_divisor <= (not divisor) + 1;
    elsif (dividend(7) = '1' and divisor(7) = '1') then
      cue <= "11";
      abs_dividend <= (not dividend) + 1;
      abs_divisor <= (not divisor) + 1;
    end if;
  end process;
end architecture decider;
	 
 library ieee ;
 use ieee.std_logic_1164.all ;
 use ieee.std_logic_arith.all ;
 use ieee.std_logic_unsigned.all;  
entity divider is
    port (dividend : in std_logic_vector(7 downto 0);
          divisor: in std_logic_vector(7 downto 0);
			 clk: in std_logic;
			 input_valid: in std_logic;
			 load_input: in std_logic;
          quotient1: out std_logic_vector(7 downto 0);
			 output_valid: out std_logic;
          remainder1: out std_logic_vector(7 downto 0));
end divider;

architecture divider of divider is
signal a : std_logic_vector(7 downto 0);
--signal quotient: std_logic_vector(7 downto 0) := "00000001";
signal b : std_logic_vector(7 downto 0);
signal bb : std_logic_vector(7 downto 0);
signal remainder: std_logic_vector(7 downto 0);
signal cue: std_logic_vector(1 downto 0);
signal output_valid_buffer: std_logic;
signal start_division: std_logic := '0';
signal real_clock: std_logic := '0';
signal i : std_logic_vector(3 downto 0) := "0000";
signal temp_remainder: std_logic_vector(13 downto 0) ;
signal temp_divisor: std_logic_vector(13 downto 0) ;
signal temp_remainder2: std_logic_vector(13 downto 0) ;
signal temp_divisor2: std_logic_vector(13 downto 0) ;
--signal real_quotient : std_logic_vector(7 downto 0) :="00000000";


begin


process(dividend, divisor)
  begin
	 if(dividend(7) = '0' and divisor(7) = '0') then
      a <= dividend;
      b <= divisor;
      cue <= "00";
    elsif(dividend(7) = '1' and divisor(7) = '0') then
      cue <= "10";
      a <= (not dividend) + 1;
      b <= divisor;
    elsif(dividend(7) = '0' and divisor(7) = '1') then
      cue <= "01";
      a <=  dividend ;
      b <= (not divisor) + 1;
    elsif (dividend(7) = '1' and divisor(7) = '1') then
      cue <= "11";
      a <= (not dividend) + 1;
      b <= (not divisor) + 1;
    end if;
  end process;
  
process(a, b,load_input)
begin
	if i = "0000" then
		if (b > "00000000") then
		temp_remainder2 <= "000000" & a;
		temp_divisor2 <= b & "000000";
		start_division <= '1';
		end if;
	elsif (i = "0111" and load_input = '0') then
	start_division <= '0';
	end if;
end process;


real_clock <= clk and start_division;

process(real_clock)
variable real_quotient : std_logic_vector( 7 downto 0) := "00000000";
begin	
    if (real_clock'event and real_clock = '1' and i <= "0110") then
         if i = "0000" then  --and assign_now = '1'
				temp_remainder <= temp_remainder2;
				temp_divisor <= temp_divisor2;
			end if;
			if (temp_divisor <= temp_remainder) then
            temp_remainder <= temp_remainder - temp_divisor;
            --quotient <= quotient + quotient;
				--quotient <= quotient + 1
				real_quotient := real_quotient + real_quotient;
				real_quotient :=  real_quotient + 1;
				--quotient <= real_quotient;
         else 
            -- quotient <= quotient + quotient;
				real_quotient := real_quotient + real_quotient;
         end if;
			
			case i is
			  when "0000" => temp_divisor <= "0" & b & "00000";
			  when "0001" => temp_divisor <= "00" & b & "0000";
			  when "0010" => temp_divisor <= "000" & b & "000";
			  when "0011" => temp_divisor <= "0000" & b & "00";
			  when "0100" => temp_divisor <= "00000" & b & "0";
			  when "0101" => temp_divisor <= "000000" & b;
			  when others => temp_divisor <= "000000" & b; 
         end case;  
			i <= i + 1;
				bb <= real_quotient;
		elsif( load_input = '0' ) then
			i <= "0000";
			real_quotient := "00000000";
			temp_remainder <= "00000000000000";
		end if;
end process;

process (i, load_input)
begin
	if( i = "0111") then
		output_valid <= '1';
		output_valid_buffer <= '1';
	elsif (load_input = '1') then
		output_valid <= '0';
		output_valid_buffer <= '0';
		
	end if;
end process;


 remainder <= temp_remainder(7 downto 0);
  process(output_valid_buffer)
  begin
 
  if output_valid_buffer = '1' then
    if(cue = "00") then
      quotient1 <= bb;
		remainder1 <= remainder;
    elsif(cue = "10") then
      quotient1 <= (not bb) + 1;
      remainder1 <= (not remainder ) + 1;
    elsif(cue = "01") then
      quotient1 <= (not bb) + 1;
		remainder1 <= remainder;
    elsif (cue = "11") then
      remainder1 <= (not remainder ) + 1;
		quotient1 <= bb;
    end if;
  end if;
  end process;

end architecture divider;





----- 2's complement to magnitude-----
library IEEE;
use IEEE.STD_LOGIC_1164.ALL;
use IEEE.STD_LOGIC_ARITH.ALL;
use IEEE.STD_LOGIC_UNSIGNED.ALL;

entity twoscomplement_mag is
    port(input: in std_logic_vector(7 downto 0);
         output: out std_logic_vector(7 downto 0));
end twoscomplement_mag;

architecture twoscomplement_mag of twoscomplement_mag is

begin
    output <= (not input) + 1;

end architecture twoscomplement_mag;



-----std_logic_vector to 2's complement------
library IEEE;
use IEEE.STD_LOGIC_1164.ALL;
use IEEE.STD_LOGIC_ARITH.ALL;
use IEEE.STD_LOGIC_UNSIGNED.ALL;

entity twoscomplement is
    port(input: in std_logic_vector(7 downto 0);
         output: out std_logic_vector(7 downto 0));
end twoscomplement;

architecture twoscomplement of twoscomplement is

begin
    output <= "1" & ((not input) + 1);
end architecture twoscomplement;



-----------------------------------
---clock


library IEEE;
use IEEE.STD_LOGIC_1164.ALL;
use ieee.std_logic_arith.all;
use ieee.STD_LOGIC_UNSIGNED.all;
entity slow_clk is
   port ( clkin : in std_logic;
      clkout : out std_logic);
end slow_clk;

Architecture slow_clk of slow_clk is
signal temp : std_logic_vector(14 downto 0) := "000000000000000";
begin
process(clkin)
begin
    if(clkin'event and clkin ='1') then
        temp <= temp +1;
    end if;
    clkout <= temp(14);
end process;
end architecture slow_clk;    

------------------------------------------
---anode

library IEEE;
use IEEE.STD_LOGIC_1164.ALL;
use ieee.std_logic_arith.all;
use ieee.STD_LOGIC_UNSIGNED.all;
use IEEE.NUMERIC_STD.ALL;
entity anodecirc is
    port(clkin : in std_logic;
          anode_buff : out std_logic_vector(3 downto 0));
end anodecirc;

architecture anodecirc of anodecirc is
signal cycle : std_logic_vector(3 downto 0):= "1110";

begin
process(clkin)
begin
        if(clkin'event and clkin = '1') then
            cycle(0) <= cycle(3);
            cycle(1) <= cycle(0);
            cycle(2) <= cycle(1);
            cycle(3) <= cycle(2);
        end if;
end process;
anode_buff <= cycle;
end architecture anodecirc;


-------------------------------------
-----seven segment

library IEEE;
use IEEE.STD_LOGIC_1164.ALL;
use ieee.std_logic_arith.all;
use ieee.STD_LOGIC_UNSIGNED.all;
use IEEE.NUMERIC_STD.ALL;

entity display is
    port( anode : in std_logic_vector(3 downto 0);
          in1 : in std_logic_vector(15 downto 0);
          cathode : out std_logic_vector(6 downto 0)
        );

end display;

architecture dis_seven of display is
begin
    process(anode,in1)
    begin
    if anode="0111" then
        case in1(15 downto 12) is 
            when "0000" => cathode <="1000000";  
            when "0001" => cathode <="1111001";
            when "0010" => cathode <="0100100";
            when "0011" => cathode <="0110000";
            when "0100" => cathode <="0011001"; 
            when "0101" => cathode <="0010010";
            when "0110" => cathode <="0000010";
            when "0111" => cathode <="1111000";
            when "1000" => cathode <="0000000";
            when "1001" => cathode <="0010000";
            when "1010" => cathode <="0001000";
            when "1011" => cathode <="0000011";
            when "1100" => cathode <="1000110";
            when "1101" => cathode <="0100001";
            when "1110" => cathode <="0000110";
            when others => cathode <="0001110";
        end case;
    end if;

    if anode="1011" then
        case in1(11 downto 8) is 
            when "0000" => cathode <="1000000";  
                when "0001" => cathode <="1111001";
                when "0010" => cathode <="0100100";
                when "0011" => cathode <="0110000";
                when "0100" => cathode <="0011001"; 
                when "0101" => cathode <="0010010";
                when "0110" => cathode <="0000010";
                when "0111" => cathode <="1111000";
                when "1000" => cathode <="0000000";
                when "1001" => cathode <="0010000";
                when "1010" => cathode <="0001000";
                when "1011" => cathode <="0000011";
                when "1100" => cathode <="1000110";
                when "1101" => cathode <="0100001";
                when "1110" => cathode <="0000110";
                when others => cathode <="0001110";
        end case;
    end if;

    if anode="1101" then
        case in1(7 downto 4) is 
           when "0000" => cathode <="1000000";  
                when "0001" => cathode <="1111001";
                when "0010" => cathode <="0100100";
                when "0011" => cathode <="0110000";
                when "0100" => cathode <="0011001"; 
                when "0101" => cathode <="0010010";
                when "0110" => cathode <="0000010";
                when "0111" => cathode <="1111000";
                when "1000" => cathode <="0000000";
                when "1001" => cathode <="0010000";
                when "1010" => cathode <="0001000";
                when "1011" => cathode <="0000011";
                when "1100" => cathode <="1000110";
                when "1101" => cathode <="0100001";
                when "1110" => cathode <="0000110";
                when others => cathode <="0001110";
        end case;
    end if;

    if anode="1110" then 
        case in1(3 downto 0) is 
           when "0000" => cathode <="1000000";  
                when "0001" => cathode <="1111001";
                when "0010" => cathode <="0100100";
                when "0011" => cathode <="0110000";
                when "0100" => cathode <="0011001"; 
                when "0101" => cathode <="0010010";
                when "0110" => cathode <="0000010";
                when "0111" => cathode <="1111000";
                when "1000" => cathode <="0000000";
                when "1001" => cathode <="0010000";
                when "1010" => cathode <="0001000";
                when "1011" => cathode <="0000011";
                when "1100" => cathode <="1000110";
                when "1101" => cathode <="0100001";
                when "1110" => cathode <="0000110";
                when others => cathode <="0001110";
        end case;
    end if;    
end process;
end dis_seven;
            
    


library IEEE;
use IEEE.STD_LOGIC_1164.ALL;

-- Uncomment the following library declaration if using
-- arithmetic functions with Signed or std_logic_vector values
--use IEEE.NUMERIC_STD.ALL;

-- Uncomment the following library declaration if instantiating
-- any Xilinx leaf cells in this code.
--library UNISIM;
--use UNISIM.VComponents.all;

entity lab7_divider is
    Port (divisor : in std_logic_vector(7 downto 0);
          dividend: in std_logic_vector(7 downto 0);
          input_valid: out std_logic;
          input_invalid : out std_logic;
          output_valid: out std_logic;
          load_inputs: in std_logic;
          anode: out std_logic_vector(3 downto 0);
          cathode: out std_logic_vector(6 downto 0);
          clk: in std_logic;
          sim_mode: in std_logic);         
end lab7_divider;

architecture Behavioral of lab7_divider is
signal dividend_buffer: std_logic_vector(7 downto 0);
signal divisor_buffer: std_logic_vector(7 downto 0);
signal remainder_buffer: std_logic_vector(7 downto 0);
signal quotient_buffer: std_logic_vector(7 downto 0);
signal buffer1: std_logic_vector(15 downto 0);
signal anode_buffer : std_logic_vector(3 downto 0);
signal clk_slow: std_logic;
signal real_clock: std_logic;
signal input_valid_buffer: std_logic;
begin


anode <= anode_buffer;


--divider
divider: entity work.divider(divider)
	port map(dividend_buffer, divisor_buffer, real_clock,input_valid_buffer, load_inputs,quotient_buffer, output_valid,remainder_buffer);
buffer1 <= quotient_buffer & remainder_buffer ;	
	

---- anode
anode_circulation: entity work.anodecirc(anodecirc)
	port map(real_clock,anode_buffer);




----seven segment
ssd : entity work.display(dis_seven)
	port map(anode_buffer,buffer1,cathode);

--slowclodck
slowclock: entity work.slow_clk(slow_clk)
	port map(clk, clk_slow);

real_clock <= (sim_mode and clk) or (not sim_mode and clk_slow);

--checker
process(divisor,load_inputs)
begin
if (divisor > "00000000") then
		if(load_inputs = '1') then
			dividend_buffer <= dividend;
        divisor_buffer <= divisor;
		end if;
    input_valid <= '1';
	 input_valid_buffer <= '1';
	 input_invalid <= '0';
else
	input_valid <= '0';
	input_invalid <= '1';
	input_valid_buffer <= '0';
end if;
end process;

end Behavioral;


